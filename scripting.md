# Скриптинг

Если вы хотите настроить какое-либо программное обеспечение, скорее всего, вы измените различные настройки в программном обеспечении в соответствии с вашим вкусом и потребностями. А что, если Вы хотите сделать больше чем это? Например, чтобы проверить условия, такие как `если GUI-версии, то использовать эту цветовую схему, иначе использовать эту цветовую схему`? Вот где появляется "скриптинг". Скриптинг означает использование языка, на котором вы можете указать условия и действия, объединенные в "скрипт".

Существует два подхода к написанию скриптов в Vim - использование встроенного языка скриптинга Vim или использование полноценного языка программирования, такого как Python или Perl, которые имеют доступ к внутренним компонентам Vim через модули (при условии, что Vim был скомпилирован с включенными этими параметрами).

Эта глава требует некоторого знания программирования. Если у вас нет опыта программирования, вы все равно сможете понять, хотя это может показаться кратким. Если вы хотите научиться программированию, пожалуйста, обратитесь к моей другой бесплатной книге [A Byte of Python]({{ book.pythonBookUrl }}).

Существует два способа создания многоразовых функций в Vim - использование макросов и написание скриптов.

## Макрос

Используя макросы, мы можем записывать последовательности команд, а затем воспроизводить их в различных контекстах.

Например, предположим, что у вас есть такой текст:

```
tansen is the singer
daswant is the painter
todarmal is the financial wizard
abul fazl is the historian
birbal is the wazir
```

Здесь есть несколько вещей для исправления:

1. Изменить первую букву предложения на верхний регистр.
2. Изменить "is" на "was".
3. Изменить "the" на "a".
4. Закончить приговор словами "in Akbar's court."

Одним из способов было бы использовать ряд команд замены, таких как `:s/^\\w/\\u\\0/`, но для этого потребуется 4 команды замены, и это может быть непросто, если команда замены изменит части текста, которые мы не хотим изменять.

Лучшим способом было бы использовать макрос.

1. Поместите курсор на первую букву первой строки: `tanses is the singer`
2. Введите `qa` в нормальном режиме, чтобы начать запись макроса с именем `a`.
3. Введите `gUl` для перевода первой буквы в верхний регистр.
4. Введите `w` чтобы перейти к следующему слову.
5. Введите `cw` чтобы изменить слово.
6. Введите `was`.
7. Нажмите `<ESC>`.
8. Введите `w` для перемещения к следующему слову.
9. Введите `cw` чтобы изменить слово.
10. Введите `а`.
11. Нажмите `<ESC>`.
12. Введите `A` чтобы вставить текст в конце строки.
13. Введите `in Akbar's court`.
14. Нажмите `<ESC>`.
15. Введите `q` для остановки записи макроса.

Это выглядит как долгая процедура, но иногда, гораздо проще сделать так чем подготовить некоторые сложные команды замены!

В конце процедуры строка должна выглядеть так:

```
Tansen was a singer in Akbar's court.
```

Отлично. Теперь давайте перейдем к применению этого к другим строкам. Просто перейдите к первому символу второй строки и нажмите `@a`. Вуаля, строка должна измениться на:

```
Daswant was a painter in Akbar's court.
```

Это демонстрирует что макросы могут записывать сложные операции и могут быть легко воспроизведены. Это помогает пользователю воспроизвести сложное редактирование в нескольких местах. И это лишь один из видов повторного использования манипуляций, которые вы можете сделать с текстом. Далее мы увидим более формальные способы манипулирования текстом.

> ПРИМЕЧАНИЕ: Если вы хотите просто повторить последнее действие, а не последовательность действий, вам не нужно использовать макросы, просто нажмите `.` (точку).

## Основы скриптинга

Vim имеет встроенный скриптовый язык, с помощью которого вы можете писать свои собственные скрипты для принятия решений, "делать" вещи и манипулировать текстом.

### Действия

Как вы меняете тему, т.е. цвета, используемые Vim? Просто запустите:

``` viml
:colorscheme desert
```

Здесь я использую цветовую схему "desert", которая является моей любимой. Вы можете просмотреть другие доступные схемы, набрав `:colorscheme', а затем нажимать клавишу `<tab>` для циклического просмотра доступных схем.

Что делать, если вы хотите узнать, сколько символов в текущей строке?

``` viml
:echo strlen(getline("."))
```

Обратите внимание на имена "strlen" и "getline". Это "функции". *Функции* - это уже написанные фрагменты скриптов, которым дано имя, чтобы мы могли использовать их снова и снова. Например, функция getline извлекает строку, и мы указываем строку как `.` (точка), что означает текущую строку. Мы передаем результат, возвращенный функцией `getline` в функцию `strlen`, которая подсчитывает количество символов в тексте, а затем передает результат, возвращенный функцией `strlen` в команду `:echo`, которая просто отображает результат. Обратите внимание, как информация течет в этой команде.

`strlen(getline("."))` называется выражением. Мы можем хранить результаты таких выражений с помощью переменных. Переменные - это имена, указывающие на значения, и значение может быть любым, т.е. оно может меняться. Например, мы можем хранить длину как:

``` viml
:let len = strlen(getline("."))
:echo "We have" len "characters in this line."
```

Когда вы запустите эту строку на второй строке в тексте выше, то получите следующий вывод:

``` viml
We have 46 characters in this line.
```

Обратите внимание как мы можем использовать переменные в других "выражениях". Возможности, которые вы можете достичь с помощью этих переменных, выражений и команд бесконечны.

Vim имеет множество типов переменных, доступных через префиксы, такие как `$` для переменных среды, `&` для параметров и `@` для регистров:

``` viml
:echo $HOME
:echo &filetype
:echo @a
```

Вы можете создавать свои собственные функции, как хорошо:
Смотрите `:help function-list` для огромного списка доступных функций.

Вы также можете создавать свои собственные функции:

``` viml
:function CurrentLineLength()
: let len = strlen(getline("."))
: return len
:endfunction
```

Теперь поместите курсор на любую строку и выполните следующую команду:

``` viml
:echo CurrentLineLength()
```
Вы должны увидеть напечатанное число.

Имена функций должны начинаться с верхнего регистра. Это делается для того, чтобы отличить встроенные функции, начинающиеся с нижнего регистра, и пользовательские, начинающиеся с верхнего.

Если вы хотите просто "вызвать" функцию для запуска, но не отображать содержимое, то можете использовать `:call CurrentLineLength()`

## Решения

Предположим, вы хотите отобразить различные цветовые схемы, основанные на том, работает ли Vim в терминале или как графический интерфейс, т.е. вам нужен скрипт для принятия решений. Для этого вы можете использовать:

``` viml
:if has("gui_running")
: colorscheme desert
:else
: colorscheme darkblue
:endif
```

Как это работает:

- `has()` - это функция, используемая для определения, поддерживается ли указанная функция в Vim, установленном на текущем компьютере. Смотрите `:help feature-list` чтобы узнать, какие функции доступны в Vim.
- Оператор `if` проверяет данное условие. Если оно выполнено, мы предпринимаем определенные действия. "Else" (Иначе) мы принимаем альтернативное действие.
- Обратите внимание, что оператор `if` должен иметь соответствующий `endif`.
- Существует также `elseif`, если вы хотите объединить несколько условий и действий.

Циклические операторы "for" и "while" также доступны в Vim:

``` viml
:let i = 0
:while i < 5
: echo i
: let i += 1
:endwhile
```

Вывод:

```
0
1
2
3
4
```

Используя встроенные функции Vim, то же самое можно также записать как:

``` viml
:for i in range(5)
:    echo i
:endfor
```

- `range()` - это встроенная функция, используемая для генерации диапазона чисел. Смотрите `:help range()` для подробностей.
- Также доступны инструкции `continue` и `break`.

## Структуры данных

Скриптинг Vim также поддерживает списки и словари. С их помощью можно создавать сложные структуры данных и программы.

``` viml
:let fruits = ['apple', 'mango', 'coconut']

:echo fruits[0]
" apple

:echo len(fruits)
" 3

:call remove(fruits, 0)
:echo fruits
" ['mango', 'coconut']

:call sort(fruits)
:echo fruits
" ['coconut', 'mango']

:for fruit in fruits
: echo "I like" fruit
:endfor
" I like coconut
" I like mango
```

Существует множество доступных функций - смотри разделы 'List manipulation' и 'Dictionary manipulation' в `:help function-list`.

## Написание скрипта Vim

Теперь мы напишем скрипт Vim, который можно загрузить в Vim, а затем вызвать для использования его функциональности по мере необходимости. Это отличается от написания встроенного скрипта и немедленного запуска, как мы делали все это время.

Давайте решим простую задачу - как насчет заглавной буквы каждого слова в выбранном диапазоне строк? Вариант использования прост - когда я пишу заголовки в текстовом документе, они выглядят лучше если заглавные, но я слишком ленив, чтобы делать это самому. Итак, я могу написать текст в нижнем регистре, а затем просто вызвать функцию для написания прописными буквами.

Начнем с базового шаблона скрипта. Сохраните следующий скрипт как файл с capitalize.vim:

``` viml
" Vim global plugin for capitalizing first letter of each word
"       in the current line.
" Last Change: 2008-11-21 Fri 08:23 AM IST
" Maintainer: www.swaroopch.com/contact/
" License: www.opensource.org/licenses/bsd-license.php

if exists("loaded_capitalize")
  finish
endif
let loaded_capitalize = 1

" TODO : The real functionality goes in here.
```

Как это работает:

- В первой строке файла должен быть комментарий, объясняющий, о чем идет речь в файле.
- Есть 2-3 стандартных заголовка, упомянутых в отношении файла, таких как 'Last Changed:' (последнее изменение), который объясняет сколько лет скрипту, "Maintainer:" (сопровождающий) - информация, чтобы пользователи скрипта могли связаться с сопровождающим скрипта по поводу каких-либо проблем или, возможно, даже благодарственным письмом.
- Заголовок "License:" (лицензия) является необязательным, но настоятельно рекомендуемым. Скрипт Vim или плагин, который вы пишете, может быть полезен и для многих других людей, поэтому вы можете указать лицензию для скрипта. Следовательно, другие люди могут улучшить вашу работу, и это, в свою очередь, принесет пользу и вам.
- Скрипт может быть загружен несколько раз. Например, если вы открываете два разных файла в одном экземпляре Vim, и оба они являются `.html` файлами, затем Vim открывает скрипт подсветки синтаксиса HTML для обоих файлов. Чтобы избежать запуска одного и того же скрипта дважды и двойного переопределения элементов, мы используем защиту, проверяя наличие имени 'loaded_capitalize' и закрывая, если скрипт уже загружен.

Теперь перейдем к написанию собственно функциональности.

Мы можем определить функцию для выполнения преобразования - заглавная первая буква каждого слова, поэтому мы можем вызвать функцию как `Capitalize()`. Поскольку функция будет работать в диапазоне, мы можем указать, что функция работает в диапазоне строк.

``` viml
" Vim global plugin for capitalizing first letter of each word
"       in the current line
" Last Change: 2008-11-21 Fri 08:23 AM IST
" Maintainer: www.swaroopch.com/contact/
" License: www.opensource.org/licenses/bsd-license.php

" Make sure we run only once
if exists("loaded_capitalize") finish
endif
let loaded_capitalize = 1

" Capitalize the first letter of each word
function Capitalize() range
  for line_number in range(a:firstline, a:lastline)
    let line_content = getline(line_number)
    " Luckily, the Vim manual had the solution already!
    " Refer ":help s%" and see 'Examples' section
    let line_content = substitute(line_content, "\\w\\+", "\\u\\0", "g")
    call setline(line_number, line_content)
  endfor
endfunction
```

Как это работает:

- `a:firstline` и `a:lastline` представляют аргументы функции, соответствующие началу и концу диапазона строк соответственно.
- Мы используем цикл 'for' для обработки каждой строки (полученной с помощью `getline()`) в диапазоне.
- Мы используем функцию `substitute()` для выполнения регулярного выражения search-and-replace в строке. Здесь мы указываем функцию для поиска слов, которая обозначается `\\w\\+`, что означает 'w'ord (слово) (т.е. непрерывный набор символов, которые являются частью слов). Как только такие слова найдены, они должны быть преобразованы с помощью `\\u\\0` - `\\u` указывает, что первый символ после этой последовательности должен быть преобразован в верхний регистр. `\\0` указывает на совпадение, найденное функцией `substitute()`, которая соответствует словам. По сути, мы преобразуем первую букву каждого слова в верхний регистр.
- Мы вызываем функцию `setline()`, чтобы заменить строку в Vim измененной строкой.

Чтобы выполнить эту команду:

1. Откройте Vim и введите произвольный текст, например 'this a test'.
2. Выполнить `:source capitalize.vim` - это 'источники' файла, как если бы команды были запущены в Vim inline, как мы делали раньше.
3. Выполнить `:call Capitalize()`.
4. Теперь строка должна выглядеть: 'This Is A Test'.

Запуск `:call Capitalize()` каждый раз кажется утомительным, поэтому мы можем назначить сочетание клавиш с помощью лидеров:

``` viml
" Vim global plugin for capitalizing first letter of each word
" in the current line
" Last Change: 2008-11-21 Fri 08:23 AM IST
" Maintainer: www.swaroopch.com/contact/
" License: www.opensource.org/licenses/bsd-license.php

" Make sure we run only once
if exists("loaded_capitalize")
  finish
endif
let loaded_capitalize = 1

" Refer ':help using-<Plug>'
if !hasmapto('<Plug>Capitalize')
  map <unique> <Leader>c <Plug>Capitalize
endif
noremap <unique> <script> <Plug>Capitalize <SID>Capitalize
noremap <SID>Capitalize :call <SID>Capitalize()<CR>

" Capitalize the first letter of each word
function s:Capitalize() range
  for line_number in range(a:firstline, a:lastline)
    let line_content = getline(line_number)
    " Luckily, the Vim manual had the solution already!
    " Refer ":help s%" and see 'Examples' section
    let line_content = substitute(line_content, "\\w\\+", "\\u\\0", "g")
    call setline(line_number, line_content)
  endfor
endfunction
```

- Мы изменили имя функции с простого `Capitalize` на `s:Capitalize` - это означает, что функция является локальной для скрипта, в котором она определена, и она не должна быть доступна глобально, потому что мы хотим избежать вмешательства в другие скрипты.
- Мы используем команду `map` для определения ярлыка.
- Клавиша `<Leader>`, обычно имеет обратную косую черту `\`.
- Теперь мы сопоставляем `<Leader>c` (т.е. клавишу лидера, за которым следует клавиша 'c') с некоторой функциональностью.
- Мы используем `<Plug>Capitalize`, чтобы указать функцию `Capitalize()`, описанную в плагине, т.е. наш собственный скрипт.
- Каждый скрипт имеет идентификатор, который обозначается `<SID>`. Таким образом, мы можем сопоставить команду `<SID>Capitalize` с вызовом локальной функции `Capitalize()`.

Итак, теперь повторите те же шаги, упомянутые ранее, чтобы протестировать этот скрипт, но теперь вы можете запустить `\c` Для заглавной буквы строки(строк) вместо запуска `:call Capitalize()`.

Этот последний набор шагов может показаться сложным, но он просто показывает, что существует множество возможностей для создания скриптов Vim, и они могут делать сложные вещи.

Если что-то пойдет не так в скрипте, то вы можете использовать `v:errmsg`, чтобы увидеть последнее сообщение об ошибке, которое может дать вам подсказки для выяснения что пошло не так.

Обратите внимание, что вы можете использовать `:help`, чтобы найти справку по всему, что мы обсуждали выше, от `:help \w` до `:help setline()`.

## Использование внешних языков программирования

Многие люди не хотели бы тратить время на изучение языка скриптов Vim и предпочли бы использовать уже известный им язык программирования и писать плагины для Vim на этом языке. Это возможно, потому что Vim поддерживает написание плагинов на Python, Perl, Ruby и многих других языках.

В этой главе мы рассмотрим простой плагин, использующий язык программирования Python,но мы также можем легко использовать любой другой поддерживаемый язык.

Как упоминалось ранее, если вы заинтересованы в изучении языка Python - вам может быть интересна моя другая бесплатная книга [A Byte of Python]({{ book.pythonBookUrl }}).

Во-первых, мы должны проверить, присутствует ли поддержка языка программирования Python.

``` viml
:echo has("python")
```

Если это возвращает `1`, то мы хорошо идем, в противном случае вы должны установить Python на вашем компьютере и попробовать еще раз.

Предположим, вы пишете сообщение в блоге. Блоггер обычно хочет, чтобы как можно больше людей читали его блог. Один из способов, которым люди находят такие сообщения в блоге - это запрос в поисковую систему. Итак, если вы собираетесь писать на тему (скажем "C V Raman" - известный индийский физик, получивший Нобелевскую премию за свою работу по рассеянию света), вы можете использовать важные фразы, которые помогут большему количеству людей найти ваш блог, когда они ищут эту тему. Например, если люди ищут "c v raman", они также могут искать "эффект Рамана", поэтому вы можете упомянуть об этом в своем блоге или статье.

Как мы находим такие родственные фразы? Оказывается, что решение довольно простое, благодаря Yahoo! Поиск.

Для начала давайте выясним, как использовать Python для доступа к текущему тексту, который мы будем использовать для создания связанных фраз.

``` viml
" Vim plugin for looking up popular search queries related
"       to the current line
" Last Updated: 2008-11-21 Fri 08:36 AM IST
" Maintainer: www.swaroopch.com/contact/
" License: www.opensource.org/licenses/bsd-license.php

" Make sure we run only once
if exists("loaded_related")
  finish
endif
let loaded_related = 1

" Look up Yahoo Search and show results to the user
function Related()
python <<EOF

import vim

print 'Length of the current line is', len(vim.current.line)
EOF
endfunction
```

Основной подход к написанию плагинов на интерфейсных языках такой же, как и для встроенного скриптового языка.

Ключевое отличие состоит в том, что мы должны передать код, написанный на языке Python, интерпретатору Python. Это достигается с помощью EOF, как показано выше - весь текст от команды `python <<EOF` до последующего `EOF` передается интерпретатору Python.

Вы можете протестировать эту программу, открыв Vim снова отдельно и запустив `:source related.vim`, а затем выполнить `:call Related()`. Это должно отображать что-то вроде `Length of the current line is 54`.

Теперь давайте перейдем к фактической функциональности программы. Yahoo! Поиск имеет то, что называется [запрос RelatedSuggestion](http://developer.yahoo.com/search/web/V1/relatedSuggestion.html) к которым мы можем получить доступ с помощью веб-сервиса. Доступ к этой веб-службе можно получить с помощью API Python, предоставляемого Yahoo!Поиск [pYsearch](http://search.sourceforge.net):

``` viml
" Vim plugin for looking up popular search queries related
" to the current line
" Last Updated: 2008-11-21 Fri 08:36 AM IST
" Maintainer: www.swaroopch.com/contact/
" License: www.opensource.org/licenses/bsd-license.php

" Make sure we run only once
if exists("loaded_related")
  finish
endif
let loaded_related = 1

" Look up Yahoo Search and show results to the user
function Related()
python <<EOF

import vim

from yahoo.search.web import RelatedSuggestion

search = RelatedSuggestion(app_id='vimsearch', query=vim.current.line)
results = search.parse_results()

msg = 'Related popular searches are:\n'
i= 1
for result in results:
    msg += '%d. %s\n' % (i, result)
    i += 1
print msg

EOF
endfunction
```

Обратите внимание, что мы используем текущую строку в Vim в качестве текущего текста, который нас интересует, вы можете изменить его на любой текст, который хотите, например, текущее слово и т.д.

Мы используем класс `yahoo.search.web.RelatedSuggestion` для запроса Yahoo!Поиск для фраз, связанных с указанным запросом. Мы возвращаем результаты, вызывая `parse_results()` на объекте результата. Затем мы перебираем результаты и показываем их пользователю.

1. Запустите `:source related.vim`
2. Введите текст `c v raman`.
3. Выполните `:call Related()`
4. Результат должен выглядеть примерно так:

```
Related popular searches are:
1. raman effect
2. c v raman india
3. raman research institute
4. chandrasekhara venkata raman
```

## Резюме

Мы изучили скриптинг с использованием собственного языка сценариев Vim, а также с использованием внешних языков скриптинга/программирования. Это важно, потому что функциональность Vim может быть расширена бесконечными способами.

Смотрите `:help eval`, `:help python-commands`, `:help perl-using` и `:help ruby-commands` для подробностей.

Чтобы погрузиться глубже в эту тему, смотрите [Learn VimScript The Hard Way by Steve Losh](http://learnvimscriptthehardway.stevelosh.com).
